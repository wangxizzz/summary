## epoll非阻塞是如何提升redis的 tps ?
- redis作者说过，redis的瓶颈不在内存与cpu上，也不在单线程的处理速度上，而是在网络io 上，因此需要引入io多路复用机制。
- 网络io才是影响性能的瓶颈，如果采用多线程模型来处理成千上万的网络请求，我们的线程在读写就绪的过程中会大量阻塞，甚至导致redis服务不可用，而且还会有大量的线程切换带来的损耗，得不偿失。
- cpu运行的速度其实很快，一秒钟可以执行海量的redis命令，所以串行执行没有问题。问题时阻塞IO会浪费大量CPU时间，CPU在大量时间都是处于空闲状态的。
- 阻塞io并发需要多线程，多线程并发不了太多。非阻塞io采用一个线程就可以并发，比如自己去轮询io是否就绪，但是这样效率不高，因此采用io多路复用，让内核(epoll)告诉上层哪个io ready了。```非阻塞的概念：tcp流，报文可能不全，这个时候不应该继续等待这个报文全部到达，而是处理下一个fd，利用编解码技术来处理完整报文问题，不完整的等待下次epoll唤醒.```

## hash表冲突太多，拉链太长怎么解决？
- 设计一个合理的hash函数
- 定义负载因子与阈值，并且设计动态扩容策略
- 选择合适的散列冲突解决办法(例如像Java的HashMap一般)

redis的hash冲突是怎样解决的：  
- 正常情况下,当 redis hashtable 中```元素的个数等于数组的长度时,就会开始扩容```,扩容的新数组是原数组大小的 2 倍.如果 Redis 正在做 bgsave(持久化) 时,可能不会去扩容,因为要减少内存页的过多分离(Copy On Write).但是如果 hashtable 已经非常满了,元素的个数达到了数组长度的 5 倍时,Redis 会强制扩容.
- redis在扩容的时候执行 rehash 策略会保留新旧两个 hashtable 结构，查询时也会同时查询两个 hashtable.Redis会将旧 hashtable 中的内容一点一点的迁移到新的 hashtable 中(会重新rehash),当迁移完成时,就会用新的 hashtable 取代之前的.当 hashtable 移除了最后一个元素之后,这个数据结构将会被删除.
- 数据搬迁的操作放在 hash 的后续指令中,也就是来自客户端对 hash 的指令操作.一旦客户端后续没有指令操作这个 hash.Redis就会使用定时任务对数据主动搬迁.
