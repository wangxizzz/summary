# 分布式数据系统
## 复制滞后问题
- 主从复制要求所有写请求都经由主节点， 而任何副本只能接受只读查询。 对于读操作 密集的负载(如Web) , 这是一个不错的选择: 创建多个从副本， 将读请求分发给这 些从副本， 从而减轻主节点负载并允许读取请求就近满足。
- 在这种扩展体系下， 只需添加更多的从副本， 就可以提高读请求的服务吞吐最。 但 是， 这种方法实际上只能用千异步复制， 如果试图同步复制所有的从副本， 则单个节 点故障或网络中断将使整个系统无法写入。 而且节点越多， 发生故障的概率越高， 所 以完全同步的配置现实中反而非常不可靠。
- 不幸的是， 如果一个应用正好从一个异步的从节点读取数据， 而该副本落后于主节 点， 则应用可能会读到过期的信息。 这会导致数据库中出现明显的不一致:由千并非 所有的写入都反映在从副本上， 如果同时对主节点和从节点发起相同的查询， 可能 会得到不同的结果。 这种不一致只是一个暂时的状态， 如果停止写数据库， 经过一 段时间之后， 从节点最终会赶上并与主节点保持一致。 这种效应也被称为最终一致性。
- “最终” 一 词有些含糊不清， 总的来说， 副本落后的程度理论上并没有上限。 正常情 况下， 主节点和从节点上完成写操作之间的时间延迟(复制滞后)可能不足1秒， 这 样的滞后， 在实践中通常不会导致太大影响。 但是， 如果系统已接近设计上限， 或者
网络存在问题， 则滞后可能轻松增加到几秒甚至几分钟不等。当滞后时间太长时， 导致的不一 致性不仅仅是 一 个理论存在的问题， 而是个实实在在 的现实问题。

## 复制滞后问题解决方案
### 读自己的写
许多应用让用户提交一些数据， 接下来查看他们自己所提交的内容。 例如客户数据库 中的记录， 亦或者是讨论主题的评论等。 提交新数据须发送到主节点， 但是当用户读 取数据时， 数据可能来自从节点。 这对于读密集和偶尔写入的负载是个非常合适的方 案。

基于主从复制的系统该如何实现写后读一致性呢？
- 如果用户访问可能会被修改的内容， 从主节点读取;否则， 在从节点读取。 这背 后就要求有一些方法在实际执行查询之前， 就已经知道内容是否可能会被修改。 例如， 社交网络上的用户首页信息通常只能由所有者编辑， 而其他人无法编辑。
因此， 这就形成一个简单的规则:总是从主节点读取用户自己的首页配置文件， 而在从节点读取其他用户的配置文件。
### 单调读
问题如下：

<img src="../imgs/单调读.png" width=600px>


单调读一致性可以确保不会发生这种异常。 这是一个比强一致性弱， 但比最终一致 性强的保证。 当读取数据时， 单调读保证， 如果某个用户依次进行多次读取， 则他绝 不会看到回滚现象， 即在读取较新值之后又发生读旧值的情况. 

实现单调读的一种方式是， 确保每个用户总是从固定的同一副本执行读取(而不同的 用户可以从不同的副本读取)。 例如 ， 基千用户ID的啥希的方法而不是随机选择副 本。 但如果该副本发生失效， 则用户的查询必须重新路由到另 一 个副本。

### 前缀一致读

对于一系列按照某 个顺序发生的写请求， 那么读取这些内容时也会按照当时写入的顺序。

如果数据 库总是以相同的顺序写入， 则读取总是看到一 致的序列， 不会发生这种反常。 然而，
在许多分布式数据库中， 不同的分区独立运行， 因此不存在全局写入顺序。 这就导致 当用户从数据库中读数据时， 可能会看到数据库的某部分旧值和另一部分新值。

一 个解决方案是确保任何具有因果顺序关系的写入都交给 一 个分区来完成， 但该方案 真实实现效率会大打折扣。 现在有一 些新的算法来显式地追踪事件因果关系，"Happened-before关系与并发 ” 。

#### Happened-before介绍

### 最终一致性
使用最终一致性系统时， 最好事先就思考这样的问题: 如果复制延迟增加到几分钟甚
至几小时， 那么应用层的行为会是什么样子?如果答案是 没问题 ， 那没得说。 但 是， 如果带来槽糕的用户体验， 那么在设计系统时， 就要考虑提供一 个更强的一致性 保证， 比如写后读;如果系统设计时假定是同步复制， 但最终它事实上成为了异步复制， 就可能会导致灾难性后果。