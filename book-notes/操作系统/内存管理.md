# 物理内存：连续分配存储管理方式

## 伙伴系统

# 物理内存非连续：页式和段式存储管理
## 虚拟存储出现的原因
在第一种连续内存管理中，为进程分配的空间是连续的，使用的地址都是物理地址。如果允许将一个进程分散到许多不连续的空间，就可以避免内存紧缩，减少碎片。基于这一思想，通过引入进程的逻辑地址，把进程地址空间与实际存储空间分离，增加存储管理的灵活性。地址空间和存储空间两个基本概念的定义如下：
- 地址空间：将源程序经过编译后得到的目标程序，存在于它所限定的地址范围内，这个范围称为地址空间。地址空间是逻辑地址的集合。
- 存储空间：指主存中一系列存储信息的物理单元的集合，这些单元的编号称为物理地址存储空间是物理地址的集合。

根据分配时所采用的基本单位不同，可将离散分配的管理方式分为以下三种：

页式存储管理、段式存储管理和段页式存储管理。其中段页式存储管理是前两种结合的产物。

# 页式存储
## 基本原理
将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量）。

页式管理方式的优点是：
- 没有外碎片
- 一个程序不必连续存放。
- 便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。

 缺点是：要求程序全部装入内存，没有足够的内存，程序就不能执行。

 ## 页式管理的数据结构
在页式系统中进程建立时，操作系统为进程中所有的页分配页框。当进程撤销时收回所有分配给它的页框。在程序的运行期间如果允许进程动态地申请空间，操作系统还要为进程申请的空间分配物理页框。操作系统为了完成这些功能，必须记录系统内中实际的页框使用情况。操作系统还要在进程切换时，正确地切换两个不同的进程地址空间到物理内存空间的映射。这就要求作系统要记录```每个进程页表的相关信息```。为了完成上述的功能，—个页式系统中，一般要采用如下的数据结构：
- 进程页表：完成逻辑页号(本进程的地址空间)到物理页面号(实际内存空间，也叫块号)的映射。
    - 每个进程有一个页表，描述该进程占用的物理页面及逻辑排列顺序
- 物理页面表：整个系统有一个物理页面表，描述物理内存空间的分配使用状况，其数据结构可采用位示图和空闲页链表。
- 请求表：整个系统有一个请求表，描述系统内各个进程页表的位置和大小，用于地址转换也可以结合到各进程的PCB(进程控制块)里。

## 页式管理地址变换
在页式系统中，指令所给出的地址分为两部分：逻辑页号和页内地址。

原理：CPU中的内存管理单元(MMU)按逻辑页号通过查进程页表得到物理页框号，将物理页框号与页内地址相加形成物理地址.

逻辑页号，页内偏移地址－>查进程页表，得物理页号－>物理地址

上述过程通常由处理器的硬件直接完成，不需要软件参与。通常，操作系统只需在进程切换时，把进程页表的首地址装入处理器特定的寄存器中即可。一般来说，页表存储在主存之中。这样处理器每访问一个在内存中的操作数，就要访问两次内存：

第一次用来查找页表将操作数的 逻辑地址变换为物理地址；

第二次完成真正的读写操作。       

这样做时间上耗费严重。为缩短查找时间，可以将页表从内存装入CPU内部的关联存储器(例如，```快表```) 中，实现按内容查找。此时的地址变换过程是：在CPU给出有效地址后，由地址变换机构自动将页号送人快表，并将此页号与快表中的所有页号进行比较，而且这 种比较是同时进行的。若其中有与此相匹配的页号，表示要访问的页的页表项在快表中。于是可直接读出该页所对应的物理页号，这样就无需访问内存中的页表。```由于关联存储器的访问速度比内存的访问速度快得多```,即一次最好的可能是 一次访问快表拿到物理地址，然后在访问主存进行真正的读写。

参考：https://blog.csdn.net/hguisu/article/details/5713164

# linux内存管理

Linux使用分页管理机制来更加有效地利用物理内存。

当创建一个进程时．仅仅把当前进程的一小部分真正装入内存．其余部分需要访问时．处理器产生一个页故障．由缺页中断服务程序根据缺页虚拟地址和出错码调用写拷贝函数do—wp—page、此地址所属的vma的vm—ops指向的nopage、do—swap—page、swap—in等函数将需要的页换入物理内存。随着可执行映像的运行和页面的换入．系统中的内存有可能变得不足．这时Linux核心就必须调用kswapd守护进程释放部分物理内存。kswapd在系统启动时由init进程建立。在系统的运行过程中。它被定期唤醒。检查系统中的空闲物理内存是否很少。如果是．则释放一部分内存．或者将一些页面换出到对换空间。然后继续睡眠。

## 缺页中断和页面换入
      页面换入主要由缺页中断服务入口函数do—page—fault来实现。当系统中产生页面故障时．如果虚拟内存地址有效．则产生错误的原因有如下两种：
         虚拟内存地址对应的物理页不在内存中。那么它必然在磁盘或对换空间中．如果在磁盘上．那么我们调用do—nO—
page函数．而do—no—page调用vma一>vm—ops一>nopage()函数建立页面映射．从对换空间或磁盘中调入页面．或者通过do—swap—page()函数调用swap—in()来换入页面。
·
          该虚拟地址对应的物理页在内存。但是被写保护．如果这种情况发生在一个共享页面上．则需要“写拷贝“函数do—
wp—page来换入页面．do—wp—page函数首先调用一get—free—page获得一新页面．然后调用copy—COW—page拷贝页面的内容．当然还要调用相应的刷新函数刷新TLB和缓存等。COW

## 缺页中断具体说明
### 定义
现代操作系统通过虚拟内存技术来扩大物理内存，虚拟内存每一页都映射在物理内存或磁盘上所以虚拟内存会比物理内存大，程序里访问的是虚拟地址，当程序访问页映射在磁盘上时，就会发生缺页中断，调用中断处理程序将页载入物理内存。例如：32位Linux的每个用户进程都可以访问4GB的线性地址空间， 而实际的物理内存可能远远少于4GB． 采用分页机制 ，Linux仅把可执行映像的一小部分装入物理内存． 当需要访问未装入的页面时 ． 系统产生一个缺页中断， 把需要的页读入物理内存。

缺页中断：即指的是当应用程序试图访问已映射在虚拟地址空间中，但是并未被加载在物理内存中的一个分页时，产生一个页不存在的中断，需要操作系统将其调入物理内存后再进行访问。在这个时候，被内存映射的文件（映像）实际上成了一个分页交换文件。

名为“缺页中断”或者“页缺失”错误，但实际上这并不一定是一种错误。而且这一机制对于利用虚拟内存来增加程序可用内存空间的操作系统。

## 页面置换算法
当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。

几种缺页中断算法: FIFO、LRU、LFU 

参考：https://blog.csdn.net/hguisu/article/details/6152921







