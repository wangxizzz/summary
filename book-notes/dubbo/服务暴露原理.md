# 原理
- 通过动态代理创建Invoker对象，在服务端生成的是AbstractProxyInvoker，所有真实的方法调用都会委托给代理，然后代理转换给服务ref调用。
- 打开Netty Server端口监听，然后进行服务元数据注册。
    - 委托具体的协议(dubbo)进行服务暴露，创建Netty Server监听端口和保存服务实例。
    - 创建注册中心对象，与注册中心建立TCP连接
    - 注册服务元数据到注册中心
    - 订阅configuration节点，监听服务动态属性变更事件

# 源码
## 生成Invoker对象
```java
// For providers, this is used to enable custom proxy to generate invoker
String proxy = url.getParameter(PROXY_KEY);
if (StringUtils.isNotEmpty(proxy)) {
    registryURL = registryURL.addParameter(PROXY_KEY, proxy);
}
// 此时的ref为接口具体实现类
Invoker<?> invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));
DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);

Exporter<?> exporter = PROTOCOL.export(wrapperInvoker);
exporters.add(exporter);

// 获取Invoker   
// org.apache.dubbo.rpc.proxy.javassist.JavassistProxyFactory#getInvoker
@Override
public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {
    // TODO Wrapper cannot handle this scenario correctly: the classname contains '$'
    final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);
    // 返回代理对象 AbstractProxyInvoker
    return new AbstractProxyInvoker<T>(proxy, type, url) {
        // 重新doInvoke方法
        @Override
        protected Object doInvoke(T proxy, String methodName,
                                    Class<?>[] parameterTypes,
                                    Object[] arguments) throws Throwable {
            return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
        }
    };
}
```

## Invoker转换为Exporter
```java
// 由于dubbo的SPI自动注入，那么在调用 PROTOCOL.export(wrapperInvoker) 时，dubbo在加载protocol扩展点时会自动注入ProtocolListenerWrapper、ProtocolFilterWrapper

// PROTOCOL.export(wrapperInvoker)调用顺序为： ProtocolListenerWrapper ->    ProtocolFilterWrapper -> DubboProtocol

// org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper#export
public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
    if (UrlUtils.isRegistry(invoker.getUrl())) {
        return protocol.export(invoker);
    }
    // 注册监听器回调
    return new ListenerExporterWrapper<T>(protocol.export(invoker),
            Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class)
                    .getActivateExtension(invoker.getUrl(), EXPORTER_LISTENER_KEY)));
}

// org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper
public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
    if (UrlUtils.isRegistry(invoker.getUrl())) {
        return protocol.export(invoker);
    }
    // 先构造InvokerChain拦截器链(会过滤provider端分组)，然后触发dubbo协议暴露
    return protocol.export(buildInvokerChain(invoker, SERVICE_FILTER_KEY, CommonConstants.PROVIDER));
}

private static <T> Invoker<T> buildInvokerChain(final Invoker<T> invoker, String key, String group) {
    Invoker<T> last = invoker;
    // 获取所有Filter
    List<Filter> filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);

    if (!filters.isEmpty()) {
    for (int i = filters.size() - 1; i >= 0; i--) {
        final Filter filter = filters.get(i);
        final Invoker<T> next = last;
        last = new Invoker<T>() {

            @Override
            public Class<T> getInterface() {
                return invoker.getInterface();
            }

            @Override
            public URL getUrl() {
                return invoker.getUrl();
            }

            @Override
            public boolean isAvailable() {
                return invoker.isAvailable();
            }

            @Override
            public Result invoke(Invocation invocation) throws RpcException {
                Result asyncResult;
                try {
                    asyncResult = filter.invoke(next, invocation);
                } catch (Exception e) {
                .....
                }
            }
```