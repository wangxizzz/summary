# 长连接宏观简介
长连接其实不算NIO这里的特点，因为BIO也可以实现长连接（每次写完数据之后手动写入结束符而不关闭流就可以了），而且连接池一般也是使用的长连接方式。  
```NIO真正解决的是阻塞问题，因为阻塞问题解决了，所以也就不需要大量连接了。```

# RPC并发调用的结果获取原理
Dubbo协议在客户端针对所有的Service类，默认是使用单一Netty长连接来处理对这些Service类的方法的RPC调用请求的，```即所有Service共享这个单一netty长连接(Netty默认单台机器的多个服务共享一个TCP长连接)。而在客户端，如在web环境中，任何一个时刻，可能存在多个线程并发对该Service进行并发调用，这些请求都是通过该单一Channel发送和获取结果的，```
## 单一长连带来的问题
Netty所有请求都是异步，如果多个线程共用一个连接，那么每个线程调用之后返回的顺序是不可控的(单个服务由多线程并发调用时)，所以有可能先发出数据的反而后得到返回值，这就使得数据对应不上了，故dubbo如何保证这些并发线程能正确获取到自己的请求结果，而不会造成数据混乱呢 ？

正如前面所说，Socket通信是一个全双工的方式，如果有多个线程同时进行远程方法调用，这时建立在client server之间的socket连接上会有很多双方发送的消息传递，前后顺序也可能是乱七八糟的，server处理完结果后，将结果消息发送给client，client收到很多消息，怎么知道哪个消息结果是原先哪个线程调用的？
## 核心实现为
客户端Request通过AtomicLong生成的当前进程全局唯一id，服务端响应回传该id；
客户端通过FUTURES静态ConcurrentHashMap保存调用id和异步结果DefaultFuture之间的关系，服务端响应时，查询根据Response的回传请求id，获取该response对应的DefaultFuture，通过CompletableFuture回调机制实现请求发起线程和结果获取线程之间的通信，最终请求发起线程得到最终的结果。

那么解决多线程使用单一长连接并发请求时包干扰的方法也有点雷同，就是给包头中添加一个标识id，服务器端响应请求时也要携带这个id，供客户端多线程领取对应的响应数据提供线索。

其实如果不考虑性能的话，dubbo完全也可以为每个客户端线程创建一个对应的服务器端线程，但这是海量高并发场景所不能接受的~~

