### 此书值得通读！

1.go的所有参数传递都是值传递。（除非带了指针与引用）

2.大写代表public,小写代表private.(方法和变量都适用)。

3.go get 下载包。  
但是会碰到包下不下来。  
利用gopm 下载无法下载的包，首先安装gopm。（注意：切换到GOPath目录，利用git下载）  
```go
go get -v github.com/gpmgo/gopm （-v 详细的输出信息）
```
下载安装完gopm后，然后利用gopm下载其他的包。利用```gopm help get```查看gopm get 的使用  
然后就可以下载包：eg: gopm get -v -g -u url;

4.**包之间的函数相互引用问题：**  
如果定义的报名不存在，那么编译器就会去下面的三个地方去找。  
```所以：在新建项目时，需要新建一个src目录，并把当前项目加入到GOPATH目录,这样在编译时，就会在项目路径下找到引用的包。```  
**去掉使用global gopath的勾，**  
<img src="../imgs/goland.png"/>
```java
src\tree\treeentry\entry.go:6:2: cannot find package "treefds" in any of:
	C:\Go\src\treefds (from $GOROOT)    // GOROOT,go的安装目录。
	D:\goprojects\demo01\src\treefds (from $GOPATH)   // 项目的gopath路径
	C:\Users\Administrator\go\src\treefds   // 全局gopath路径
```

5.**语法介绍：**
```go
fmt.Printf("%T %V\n", r, r)  // %T ->Type, %V -> Value. 可以打印出对象的类型与值。
```
- 一个目录下，只能有一个包。如果已经定义为main包，那么就不能定义其他的包了。
- go没有继承与多态，因此只有struct，没class.
- go中的Reader与Writer传的参数可以为文件，网络，slice
- ```闭包：```
	- 匿名函数同样被称之为闭包（函数式语言的术语）：它们被允许调用定义在其它环境下的变量。闭包可使得某个函数捕捉到一些外部状态，例如：函数被创建时的状态。另一种表示方式为：一个闭包继承了函数所声明时的作用域。这种状态（作用域内的变量）都被共享到闭包的环境中，因此这些变量可以在闭包中被操作，直到被销毁。闭包经常被用作包装函数：它们会预先定义好 1 个或多个参数以用于包装。另一个不错的应用就是使用闭包来完成更加简洁的错误检查。
	- 所谓闭包是指内层函数引用了外层函数中的变量或称为引用了自由变量的函数，其返回值也是一个函数，了解过的语言中有闭包概念的像 js，python，golang 都类似这样。
	- **官方解释（译文）**：Go 函数可以是一个闭包。闭包是一个函数值，它引用了函数体之外的变量。 这个函数可以对这个引用的变量进行访问和赋值；换句话说这个函数被“绑定”在这个变量上。
- **defer关键字**：https://www.jianshu.com/p/5b0b36f398a2
	- 哪怕函数意外崩溃终止，也能保证关键字 defer 安排调用的函数会被执行。
- **recover:** 仅在defer中调用，可以获取panic的值，如果无法处理，那么可以重新panic.
- **Go中的接口与组合：**
	- 在 Go 语言中，如果一个类型实现了一个接口的所有方法，那么这个类型的实
例就可以存储在这个接口类型的实例中，不需要额外声明。
- **go的变量申明：**
	- 根据经验，如果需要声明初始值为零值
的变量，应该使用 var 关键字声明变量；如果提供确切的非零值初始化变量或者使用函数返回
值创建变量，应该使用简化变量声明运算符(结合make初始化)。
- **空白标识符** 
	- 下划线字符（ _）在 Go 语言里称为空白标识符，有很多用法。这个标识符用来抛弃不
想继续使用的值，如给导入的包赋予一个空名字，或者忽略函数返回的你不感兴趣的值。
- **go install** : 编译指定包或文件，并在bin目录下生成.exe文件.
	- go install project01/ ...  表示编译project01项目的所有包。
- **切片**： 
	- 切片是一个很小的对象，对底层数组进行了抽象。切片是一种数据结构，这种数据结构便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。切片的动态增长是通过内置函append来实现的。这个函数可以快速且高效地增长切片。还可以通过对切片再次切片来缩小一个切片的大小。因为切片的底层内存也是在连续块中分配的，所以切片还能获得索引、迭代以及为垃圾回收优化的好处。
- **关于array,slice,map在函数间传递：** 假如在main中定义，传入到A函数中修改：
	- array: 值传递。在A函数修改，并不影响main中的array的值。除非A函数返回修改后的数组。
	- slice:在 64 位架构的机器上，一个切片需要 24 字节的内存：指针字段需要 8 字节，长度和容量字段分别需要 8 字节。由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片复制到任意函数的时候，对底层数组大小都不会有影响。复制时只会复制切片本身，不会涉及底层数组。
	如下图：
	<img src="../imgs/slice复制.png" />
	- map:在函数间传递映射```并不会```制造出该映射的一个副本。实际上，当传递映射给一个函数，并对
这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改。映射的键可以是任何值。这个值的类型可以是内置的类型，也可以是结构类型，只要这个值可以使用==运算符做比较。切片、函数以及包含切片的结构类型这些类型由于具有引用语义，不能作为映射的键。
- **将切片或者映射传递给函数成本很小，并且不会复制底层的数据结构。**
- **嵌入类型** ：
	- Go 语言允许用户扩展或者修改已有类型的行为。这个功能对代码复用很重要，在修改已有
类型以符合新类型的时候也很重要。这个功能是通过嵌入类型（ type embedding）完成的。嵌入类
型是将已有的类型直接声明在新的结构类型里。被嵌入的类型被称为新的外部类型的内部类型。
通过嵌入类型，与内部类型相关的标识符会提升到外部类型上。这些被提升的标识符就像直
接声明在外部类型里的标识符一样，也是外部类型的一部分。这样外部类型就组合了内部类型包
含的所有属性，并且可以添加新的字段和方法。外部类型也可以通过声明与内部类型标识符同名
的标识符来覆盖内部标识符的字段或者方法。这就是扩展或者修改已有类型的方法。（可以参见本书5.5）
- **fmt.Sprintf()函数：**
	- http://liyangliang.me/posts/2014/06/donnot-use-fmt-sprintf-for-type-conversion/
- **关于chan的关闭close()**:
	- 关闭通道的代码非常重要。当通道关闭后， goroutine 依旧可以从通道接收数据，但是不能再向通道里发送数据。能够从已经关闭的通道接收数据这一点非常重要，因为这允许通道关闭后依旧能取出其中缓冲的全部值，而不会有数据丢失。从一个已经关闭且没有数据的通道里获取数据，总会立刻返回，并返回一个通道类型的零值，在使用for range时，会随着close()调用而结束for循环。
- **select的用法与场景：**
	- http://yanyiwu.com/work/2014/11/08/golang-select-typical-usage.html
- **详解 Go 语言中的 time.Duration 类型：**
	- https://studygolang.com/articles/12617
- 

6.**go的特点：**  
Go 语言是一种静态类型的编程语言。这意味着，编译器需要在编译时知晓程序里每个值的
类型。如果提前知道类型信息，编译器就可以确保程序合理地使用值。这有助于减少潜在的内存
异常和 bug，并且使编译器有机会对代码进行一些性能优化，提高执行效率。

7.**应该使用值接收者，还是应该使用指针接收者？**  
- ```值接收者使用值的副本来调用方法，而指针接受者使用实际值来调用方法```。  
- 值接收者或指针接收者都既可以使用类型值和类型指针来调，编译器做了优化，(这是没有接口的情况下，直接用实现的类型来调方法) 。   
- 在利用接口的实现，来初始化接口变量r时，**如果接口的实现定义的是指针接收者**，那么初始化时，需要取实现的地址， 注意：这个和直接使用接口的实现来调用接口方法不一样，参见第二条。  
```具体可以仔细阅读《go语言实战》5.4节，讲的很清楚。```

8.**goroutin深入理解：通读第六章**
- Go 语言的并发同步模型来自一个叫作通信顺序进程（ Communicating Sequential Processes， CSP）
的范型（ paradigm）。 CSP 是一种消息传递模型，通过在 goroutine 之间传递数据来传递消息，而不是
对数据进行加锁来实现同步访问。用于在 goroutine 之间同步和传递数据的关键数据类型叫作通道
（ channel）。对于没有使用过通道写并发程序的程序员来说，通道会让他们感觉神奇而兴奋。希望读
者使用后也能有这种感觉。使用通道可以使编写并发程序更容易，也能够让并发程序出错更少。
- ```runtime.Gosched()``` : 当前 goroutine 从线程退出，并放回到队列。
- 

9.**关于go的一些问题：**：  
- **一个奇怪的golang对切片的竞争检测问题：**
	- https://juejin.im/entry/5cbd66316fb9a031fe3bc565
- **为什么在Go语言中要慎用interface{}：**
	- https://juejin.im/post/5ad1c766518825555e5e4646#heading-0
- 

10.关于lock:  
```go
// mutex is used to define a critical section of code.
mutex sync.Mutex

mutex.Lock()
// 使用大括号只是为了让临界区看起来更清晰，并不是必需的
{
	// Capture the value of counter.
	value := counter

	// Yield the thread and be placed back in queue.
	runtime.Gosched()

	// Increment our local value of counter.
	value++

	// Store the value back into counter.
	counter = value
}
mutex.Unlock()
```
对 counter 变量的操作在 Lock()和 Unlock()函数调用定义的临界
区里被保护起来。**使用大括号只是为了让临界区看起来更清晰，并不是必需的。**

11.**ticker与timer介绍：**  
