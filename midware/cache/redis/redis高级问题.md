# redis rdb fork子进程问题
使用 fork 的目的最终一定是为了不阻塞主进程来提升 Redis 服务的可用性，但是到了这里我们其实能够发现两个问题：
- 为什么 fork 之后的子进程能够获取父进程内存中的数据？
- fork 函数是否会带来额外的性能开销，这些开销我们怎么样才可以避免？

解决：
- 通过 fork 生成的父子进程会共享包括内存空间在内的资源；
- fork 函数并不会带来明显的性能开销，尤其是对内存进行大量的拷贝，它能通过写时拷贝将拷贝内存这一工作推迟到真正需要的时候；

直接fork内存拷贝带来的问题：
- 内存中存储大量的数据，fork 时拷贝内存空间会消耗大量的时间和资源，会导致程序一段时间的不可用；
- Redis 占用了 10G 的内存，而物理机或者虚拟机的资源上限只有 16G，在这时我们就无法对 Redis 中的数据进行持久化，也就是说 Redis 对机器上内存资源的最大利用率不能超过 50%；

如果无法解决上面的两个问题，使用 fork 来生成内存镜像的方式也无法真正落地，不是一个工程中真正可以使用的方法。

cow作用：  
fork之后主线程进行写操作时，会把对应物理内存复制一份进行修改，子进程还是使用原来的物理内存页，子进程rdb快照的是fork那一瞬间的内存快照，后续修改其实和rdb的内容没关系了，因为是复制一份出来修改。这就是cow. 所以redis的实例不要开2M大页，物理内存页越大，写时复制越慢。

写时拷贝的主要作用就是将拷贝推迟到写操作真正发生时，这也就避免了大量无意义的拷贝操作。在一些早期的 unix 系统上，系统调用 fork 确实会立刻对父进程的内存空间进行复制，但是在今天的多数系统中，fork 并不会立刻触发这一过程：

<img src="../../../imgs/fork.png" width=600px>

在 Redis 服务中，子进程只会读取共享内存中的数据，它并不会执行任何写操作，只有父进程会在写入时才会触发共享的内存以页为单位进行拷贝，在拷贝的页基础上进行修改，而对于大多数的 Redis 服务或者数据库，写请求往往都是远小于读请求的。

```在执行fork的时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，即fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一个写命令 ），操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork那一刻的内存数据。```

```Redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。这使得我们可以通过定时备份RDB文件来实 现Redis数据库备份。RDB文件是经过压缩（可以配置rdbcompression参数以禁用压缩节省CPU占用）的二进制格式，所以占用的空间会小于内存中的数据大小，更加利于传输。```

## 那么rdb时内存到底会不会double ?  
极端情况会，在内存中的key-value全部被修改，父进程此时就会全量cow进行修改，此时会发生double内存情况。

参考：  
- https://draveness.me/whys-the-design-redis-bgsave-fork/
- https://www.cnblogs.com/xiaolovewei/p/9038220.html

## 为什么要fork子进程而不是用子线程去做
如果子线程去做备份的时候没法保证数据的一致性，因为子线程会共享内存，在发生数据修改时，就会反映到共享内存中，如果需要单独的内存需要重新copy一份内存这样对于性能而言是非常不适合的。  

而用fork的话，子进程虽然会和父进程共享内存空间的页帧，但是fork的时候会把共享的页帧设置为只可读的状态，当任意一方尝试去写这个内存的时候，就产生一个异常，这时内核就把这个页复制到一个新的页帧中并标记为可写。这就是我们所说的copy on write.另外子进程退出的时候也会释放掉只属于子进程的内存空间，这样就创建了一个完美的snapshot。

这样也能解释为什么要在fork完子进程的时候，要把redis的键值空间设置为禁止rehash，因为redis是采用的渐进式hash的方式，如果处于rehash 无论set 或者get方式都会对旧的空间进行更改，这样就会不断的触发页帧写的异常，而需要分配更多的内存空间，这样对于性能还是受比较多的影响，但是rdb触发并没有判断是否处于rehash状态，所以rdb的方案是在必须执行的条件下，在rdb过程中尽量减少对页帧的修改而不是完全禁止。

参考：https://bbs.huaweicloud.com/blogs/220919

## 进程与线程的区别：
内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。

