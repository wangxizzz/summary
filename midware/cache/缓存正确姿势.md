## 1.缓存访问问题：
使用缓存通常的操作是，请求先访问缓存数据，如果缓存中不存在的话，就会回源到数据库中然后将数据写入到缓存中；如果存在的话就直接返回数据。从整个过程来看，缓存层就处于数据访问的前置环节，分担数据库在高并发容易出现系统故障的风险，所以在使用过程中需要对缓存层很谨慎的进行分析。在访问缓存数据时，有常见的三大场景：缓存穿透、缓存击穿以及缓存雪崩。
### 1.1 缓存穿透
1.**现象**：每次请求直接穿透缓存层，直接回源到数据库中，给数据库带来了巨大访问压力，甚至宕机。

2.**原因**：访问数据会先访问缓存，如果数据不存在缓存中才会查询数据库，```但是如果查询数据库也查询不出来数据，也是说当前访问数据永远不会写入缓存中。这样就导致了，访问一定不存在的数据```，就相当于缓存层形同虚设，每次请求都会到db层，造成数据库负担过大。

**解决方案：**
- 方案一：采用bloom filter保存缓存过的key，在访问请求到来时可以过滤掉不存在的key，防止这些请求到db层；
- 方案二：如果db查询不到数据，保存空对象到缓存层，设置较短的失效时间；
- 方案三：针对业务场景对请求的参数进行有效性校验，防止非法请求击垮db。


### 2.2 缓存击穿

现象：当某一key失效时，造成大量请求到db层，击垮存储层。

原因：为了保证缓存数据的时效性，通常会设置一个失效时间，```如果是热点key，高并发时会有海量请求直接越过缓存层到数据库```，这样就会给数据库造成的负担增大，设置宕机。

解决方案:
- 方案一：使用互斥锁，当缓存数据失效时，保证一个请求能够访问到数据库，并更新缓存，其他线程等待并重试；
- 方案二：缓存数据“永远不过期”，如果缓存数据不设置失效时间的话，就不会存在热点key过期造成了大量请求到数据库。但是，缓存数据就变成“静态数据”，```因此当缓存数据快要过期时，采用异步线程的方式提前进行更新缓存数据```。


### 2.3 缓存雪崩

现象：多个key失效，造成大量请求到db层，导致db层负担过重甚至宕机。

原因：缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到数据库，最终导致数据库瞬时压力过大而崩溃。

解决方案：
- 方案一：多每个key的失效时间在基础时间上再加上一个```1~5分钟的随机值```，这样就能保证大规模key集体失效的概率，并且需要尽量让多个key的失效时间能够均匀分布；


2.4 总结
- ```缓存穿透```：强调是获取本不存在的缓存数据，请求必然会越过缓存层直接到达到存储层，很明显这是利用业务规则的漏洞对系统发起攻击(**恶意攻击系统**)，解决方案的核心原则是过滤这些非法业务请求，与是否是热点数据、缓存失效时间等因素没有关系
- ```缓存击穿```：强调的是热点key的失效，导致某一时刻大量请求会直接到db层，解决方案的核心原则是规避数据库的并发操作;
- ```缓存雪崩```：强调的多个key的集体失效，与key是否是热点数据并不是必然的因素，解决方案的核心原则则让key之间的失效时间分布更加均匀，避免集体失效的情况

## 2.2缓存更新问题：
