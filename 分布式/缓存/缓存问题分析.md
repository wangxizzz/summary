# 方案设计
缓存方案不要设计的过分复杂，否则数据不一致的问题突出，会带来很大的问题。

# 主从延迟
- 更换为强一致性架构
- 读主库
mysql的主从延迟也是类似的解决方案。

# 缓存穿透
缓存穿透是指缓存没有发挥作用，业务系统虽然去缓存查询数据，但缓存中没有数据，业务系统需要再次去存储系统查询数据。通常情况下有两种情况：
- 存储数据不存在
- 缓存数据生成耗费大量时间或者资源
    - 典型的就是电商的商品分页，假设我们在某个电商平台上选择“手机”这个类别查看，由于数据巨大，不能把所有数据都缓存起来，只能按照分页来进行缓存。
    - ```这种比较典型的解决方案：预缓存，提前加载后几页的数据。类似于抖音提前加载后2~3个视频一般。```

## 解决方案
缓存预热，缓存异步更新，不设置过期时间。

# 缓存雪崩
缓存雪崩是指当大面积缓存失效（过期）后引起系统性能急剧下降的情况。当缓存过期被清除后，业务系统需要重新生成缓存，因此需要再次访问存储系统。

## 解决方案
## 方案1
采取了双key策略：要缓存的key过期时间是t，key1没有过期时间。每次缓存读取不到key时就返回key1的内容，然后触发一个事件。这个事件会同时更新key和key1。

## 方案2
1、由后台线程来更新缓存，而不是由业务线程来更新缓存，缓存本身的有效期设置为永久，后台线程定时更新缓存。(缓存命中有一定时间的间隔空隙，采用步骤2来弥补,当然可以把间隔时间设置比过期时间短)

2、业务线程发现缓存失效后，通过消息队列发送一条消息通知后台线程更新缓存(也可以起异步线程去更新)。可能会出现多个业务线程都发送了缓存更新消息，但其实对后台线程没有影响，后台线程收到消息后更新缓存前可以判断缓存是否存在，存在就不执行更新操作。这种方式实现依赖消息队列，复杂度会高一些，但缓存更新更及时，用户体验更好。

```后台更新机制还适合业务刚上线的时候进行缓存预热。缓存预热指系统上线后，将相关的缓存数据直接加载到缓存系统，而不是等待用户访问才来触发缓存加载。```

# 缓存热点
缓存热点的解决方案就是复制多份缓存副本，将请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力。以微博为例，对于粉丝数超过 100 万的明星，每条微博都可以生成 100 份缓存，缓存的数据是一样的，通过在缓存的 key 里面加上编号进行区分，每次读缓存时都随机读取其中某份缓存。

缓存副本设计有一个细节需要注意，就是不同的缓存副本不要设置统一的过期时间，否则就会出现所有缓存副本同时生成同时失效的情况，从而引发缓存雪崩效应。正确的做法是设定一个过期时间范围，不同的缓存副本的过期时间是指定范围内的随机值。

热点数据存在相当的突发性，临时的扩容似乎也来不及，可以采取以下：
```
1. 限流
2. 容器化+动态化
3. 业务降级，例如限制评论
```